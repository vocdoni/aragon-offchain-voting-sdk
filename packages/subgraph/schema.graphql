# Types

# Executions

type Action @entity {
  id: ID!
  to: Bytes!
  value: BigInt!
  data: Bytes!
  dao: Dao!
  proposal: IProposal!
  execResult: Bytes
}

# Dao

type Dao @entity {
  id: ID! # use address as id
  actions: [Action!]! @derivedFrom(field: "dao")
  proposals: [IProposal!]! @derivedFrom(field: "dao")
  plugins: [Plugin!]! @derivedFrom(field: "dao")
}

# Plugins

type PluginPreparation @entity(immutable: true) {
  # OSX related data
  id: ID! # psp setupId + installationId

  # Set plugin specific related data below:
}

interface PluginInstallation @entity {
  # OSX related data
  id: ID! # psp installationId
  dao: Dao!

  # Set plugin specific related data below:
}

# Plugin

type Plugin implements PluginInstallation @entity {
  "OSX related data"
  id: ID! # psp installationId
  dao: Dao!

  "Set plugin specific related data below:"
  address: String
  onlyExecutionMultisigProposalCreation: Boolean
  minTallyApprovals: Int
  minParticipation: BigInt
  supportThreshold: BigInt
  minVoteDuration: BigInt
  minTallyDuration: BigInt
  daoTokenAddress: String
  censusStrategyURI: Bytes
  minProposerVotingPower: BigInt

  executionMultisigMembers: [String!]

  proposals: [PluginProposal!]! @derivedFrom(field: "plugin")
  members: [PluginMember!]! @derivedFrom(field: "plugin")
}

type PluginMember @entity {
  id: ID! # plugin_address + member_address
  address: String # address as string to facilitate filtering by address on the UI
  balance: BigInt!
  plugin: Plugin!
  proposals: [PluginProposalMember!]! @derivedFrom(field: "approver")
  delegatee: PluginMember
  votingPower: BigInt
  # we assume token owners and/or delegatees are members
  delegators: [PluginMember!]! @derivedFrom(field: "delegatee")
}

type PluginProposalMember @entity(immutable: true) {
  "MemberProposal for Many-to-Many"
  id: ID! # approver + proposal
  approver: PluginMember!
  proposal: PluginProposal!
  createdAt: BigInt!
}

# Proposal
interface IProposal {
  id: ID! # package + proposalId
  dao: Dao!
  creator: Bytes!
  metadata: String
  actions: [Action!]! @derivedFrom(field: "proposal")
  allowFailureMap: BigInt!
  failureMap: BigInt
  executed: Boolean!
  createdAt: BigInt!
  startDate: BigInt!
  executionTxHash: Bytes
}

type PluginProposal implements IProposal @entity {
  id: ID! # plugin + proposalId
  dao: Dao!
  metadata: String
  actions: [Action!]! @derivedFrom(field: "proposal")
  allowFailureMap: BigInt!
  failureMap: BigInt
  plugin: Plugin!

  pluginProposalId: BigInt!
  vochainProposalId: Bytes!

  creator: Bytes!
  startDate: BigInt!
  createdAt: BigInt!
  voteEndDate: BigInt!
  tallyEndDate: BigInt!

  creationBlockNumber: BigInt!
  snapshotBlock: BigInt!
  executed: Boolean!
  executionDate: BigInt
  executionBlockNumber: BigInt
  executionTxHash: Bytes
  approvers: [PluginProposalMember!]! @derivedFrom(field: "proposal")

  tally: [TallyElement!] @derivedFrom(field: "proposal")
  tallyApproved: Boolean!
}

type TallyElement @entity {
  id: ID!
  proposal: PluginProposal!
  values: [BigInt!]
}
